# Node Implementation Checklist

> MANDATORY: Every new node MUST include ALL items below.

## Key Imports

```python
# Domain layer
from casare_rpa.domain.decorators import executable_node, node_schema
from casare_rpa.domain.schemas import PropertyDef, PropertyType, NodeSchema
from casare_rpa.domain.interfaces import INode, IExecutionContext
from casare_rpa.domain.entities.base_node import BaseNode

# For HTTP nodes - NEVER use raw httpx/aiohttp
from casare_rpa.infrastructure.http import UnifiedHttpClient, get_unified_http_client
```

## Checklist

### 1. @executable_node decorator
Adds exec_in/exec_out ports automatically.
```python
from casare_rpa.domain.decorators import executable_node
```

### 2. @node_schema decorator
Defines property schema for auto-widget generation.

```python
from casare_rpa.domain.decorators import node_schema
from casare_rpa.domain.schemas import PropertyDef, PropertyType
```

**PropertyTypes:** STRING, TEXT, INTEGER, FLOAT, BOOLEAN, CHOICE, JSON, FILE_PATH, DIRECTORY_PATH, CODE, SELECTOR

**Tabs:** "connection" (credentials), "properties" (main), "advanced" (optional)

```python
@node_schema(
    PropertyDef("url", PropertyType.STRING, required=True, label="URL"),
    PropertyDef("timeout", PropertyType.INTEGER, default=30000, tab="advanced"),
)
@executable_node
class MyNode(BaseNode): ...
```

**Widget Auto-Generation Order:**
1. `super().__init__()` calls `_auto_create_widgets_from_schema()`
2. Auto-generated widgets created from `__node_schema__` attribute
3. Manual widget code in `__init__()` runs AFTER auto-generation
4. Use `_replace_widget()` to override auto-generated widgets

### Dual-Source Pattern (Port vs Config)
Values come from either port connections (runtime) OR config (design-time):
```python
# RECOMMENDED: Use get_parameter() - checks port first, then config
value = self.get_parameter("url", default="")

# DON'T: Access config directly (misses port connections)
value = self.config.get("url", "")  # BAD
```

### 3. Reusable PropertyDef constants
Create UPPERCASE constants for shared properties. Export from package `__init__.py`.

```python
MY_API_TOKEN = PropertyDef("api_token", PropertyType.STRING, tab="connection", ...)
MY_CREDENTIAL_NAME = PropertyDef("credential_name", PropertyType.STRING, tab="connection", ...)
```

### 4. Visual node class
Create in: `src/casare_rpa/presentation/canvas/visual_nodes/{category}/`

**Required:** `__identifier__`, `NODE_NAME`, `NODE_CATEGORY`

**Optional:** `CASARE_NODE_CLASS` (auto-derived: VisualFooNode -> FooNode)

**Class Name Auto-Derivation:**
- Visual class "VisualImageClickNode" auto-maps to domain "ImageClickNode"
- Only set CASARE_NODE_CLASS if name doesn't follow pattern

**Manual Widget Rules:**
- PREFER: Let @node_schema auto-generate widgets (empty `__init__` body)
- OVERRIDE: Use `_replace_widget()` for file/directory path widgets
- AVOID: Don't add manual widgets that duplicate schema-defined properties

**Common Error - NodePropertyError "property already exists":**
```python
# BAD (causes error):
# Domain: @node_schema(SELECTOR_PROP, TIMEOUT_PROP)
# Visual:
def __init__(self):
    super().__init__()
    self.add_text_input("selector", ...)  # ERROR! Already in schema

# GOOD (let schema handle it):
def __init__(self):
    super().__init__()
    # Widgets auto-generated by @node_schema decorator
```

**Example:**
```python
class VisualMyNode(VisualNode):
    __identifier__ = "casare_rpa.mycategory"
    NODE_NAME = "My Node"
    NODE_CATEGORY = "mycategory"
    # CASARE_NODE_CLASS auto-derived to "MyNode"

    def __init__(self) -> None:
        super().__init__()
        # Widgets auto-generated by @node_schema decorator
```

### 5. Unit tests
- Location: `tests/nodes/{category}/test_{module}.py`
- Test: SUCCESS, ERROR, EDGE_CASES scenarios
- Use category fixtures from conftest.py

### 6. Export from __init__.py files
- Logic node: `src/casare_rpa/nodes/{category}/__init__.py`
- Visual node (category): `src/casare_rpa/presentation/canvas/visual_nodes/{category}/__init__.py`

**CRITICAL - Visual node MAIN export:**
File: `src/casare_rpa/presentation/canvas/visual_nodes/__init__.py`
1. Add to category import section
2. Add to `__all__` list

Without MAIN export, node WON'T appear in menu!

### 7. Register in _NODE_REGISTRY (Lazy Loading)
File: `src/casare_rpa/nodes/__init__.py`

The registry uses **lazy loading** - nodes are only imported when first accessed.

```python
_NODE_REGISTRY = {
    ...
    # Simple: class name matches key
    "MyNode": "mycat.mycat_nodes",

    # Tuple: when class name differs or for aliases
    "DesktopClickNode": ("desktop_nodes", "ClickElementNode"),
}
```

**Utility Functions:**
```python
from casare_rpa.nodes import get_all_node_classes, preload_nodes

# Preload specific nodes for faster first access
preload_nodes(["ClickElementNode", "TypeTextNode"])

# Get all node classes (forces full load)
all_classes = get_all_node_classes()
```

### 8. Register in workflow_loader.py NODE_TYPE_MAP
**CRITICAL:** Without this, "Node X not found in workflow" error occurs!

File: `src/casare_rpa/utils/workflow/workflow_loader.py`
```python
# In imports:
from casare_rpa.nodes.interaction_nodes import ImageClickNode

# In NODE_TYPE_MAP:
NODE_TYPE_MAP = {
    ...
    "ImageClickNode": ImageClickNode,
}
```

**Why both _NODE_REGISTRY AND NODE_TYPE_MAP?**
- `_NODE_REGISTRY`: Maps visual nodes -> domain nodes (instantiation)
- `NODE_TYPE_MAP`: Deserializes saved workflows for execution

## File Structure

```
# Logic node
src/casare_rpa/nodes/mycat/
├── __init__.py          # Export nodes + PropertyDef constants
├── mycat_base.py        # Base class with shared logic
└── mycat_nodes.py       # Node implementations

# Visual node
src/casare_rpa/presentation/canvas/visual_nodes/mycat/
├── __init__.py          # Export visual nodes
└── nodes.py             # VisualNode subclasses

# CRITICAL exports
src/casare_rpa/presentation/canvas/visual_nodes/__init__.py
src/casare_rpa/utils/workflow/workflow_loader.py

# Tests
tests/nodes/mycat/
├── __init__.py
├── conftest.py          # Category fixtures
└── test_mycat_nodes.py
```

## HTTP Nodes: Use UnifiedHttpClient

**NEVER use raw httpx or aiohttp.** Always use infrastructure HTTP client:

```python
from casare_rpa.infrastructure.http import UnifiedHttpClient

async def execute(self, context: IExecutionContext) -> ExecutionResult:
    async with UnifiedHttpClient() as client:
        response = await client.get(url, timeout=timeout)
        data = await response.json()
    return {"success": True, "data": data}
```

Features included automatically:
- Connection pooling (max 10 sessions)
- Retry with exponential backoff (3 retries)
- Rate limiting (10 req/sec per domain)
- Circuit breaker (5 failures triggers break)
- SSRF protection (blocks localhost/private IPs)
