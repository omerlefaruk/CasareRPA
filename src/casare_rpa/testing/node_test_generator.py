"""
CasareRPA - Node Test Generator.

Automatically generates test stubs for nodes based on their schema.
"""

from __future__ import annotations

from pathlib import Path
from typing import Any, Dict, Optional, Type

from loguru import logger


class NodeTestGenerator:
    """
    Generate test stubs for CasareRPA nodes.

    Analyzes node classes and generates pytest test files with
    appropriate test cases based on input/output ports and configuration.

    Example:
        generator = NodeTestGenerator(output_dir="tests/nodes")

        # Generate for a single node
        test_code = generator.generate_for_node(ClickElementNode)
        print(test_code)

        # Generate for all nodes
        generator.generate_all()
    """

    TEST_TEMPLATE = '''"""
Tests for {node_name}.

Auto-generated by NodeTestGenerator.
"""

import pytest
from unittest.mock import AsyncMock, MagicMock, patch

from {module_path} import {node_name}
from casare_rpa.testing import MockExecutionContext


class Test{node_name}:
    """Test suite for {node_name}."""

    @pytest.fixture
    def node(self):
        """Create node instance."""
        return {node_name}()

    @pytest.fixture
    def context(self):
        """Create mock execution context."""
        return MockExecutionContext()

    def test_node_creation(self, node):
        """Test node can be instantiated."""
        assert node is not None
        assert node.NODE_NAME == "{node_display_name}"

    def test_node_has_required_ports(self, node):
        """Test node has expected input/output ports."""
{port_assertions}

    @pytest.mark.asyncio
    async def test_execute_success(self, node, context):
        """Test successful node execution."""
        # Setup inputs
{input_setup}

        # Execute
        result = await node.execute(context)

        # Assert
        assert result is not None
        # TODO: Add specific assertions based on node behavior
        if not result:
             logger.warning(f"Node execution result is empty for {node.NODE_NAME} - Verify if this is expected")

    @pytest.mark.asyncio
    async def test_execute_missing_required_input(self, node, context):
        """Test execution with missing required input."""
        # Don't set any inputs
        result = await node.execute(context)

        # Should fail gracefully
        # Should fail gracefully
        # logger.info("Verified graceful failure handling")
        # assert not result.success or result is not None

{additional_tests}
'''

    PORT_ASSERTION_TEMPLATE = '        assert "{port_name}" in [p.name for p in node.{port_type}s]'

    INPUT_SETUP_TEMPLATE = '        context.set_variable("{input_name}", {default_value})'

    def __init__(self, output_dir: str = "tests/nodes") -> None:
        """
        Initialize test generator.

        Args:
            output_dir: Directory for generated test files
        """
        self.output_dir = Path(output_dir)

    def generate_for_node(
        self,
        node_class: Type,
        write_file: bool = False,
    ) -> str:
        """
        Generate test file for a node class.

        Args:
            node_class: Node class to generate tests for
            write_file: Whether to write to file

        Returns:
            Generated test code as string
        """
        node_name = node_class.__name__
        module_path = node_class.__module__

        # Get node metadata
        node_display_name = getattr(node_class, "NODE_NAME", node_name)
        category = getattr(node_class, "CATEGORY", "unknown")

        # Analyze ports
        port_assertions = self._generate_port_assertions(node_class)
        input_setup = self._generate_input_setup(node_class)
        additional_tests = self._generate_additional_tests(node_class)

        # Generate test code
        test_code = self.TEST_TEMPLATE.format(
            node_name=node_name,
            node_display_name=node_display_name,
            module_path=module_path,
            port_assertions=port_assertions,
            input_setup=input_setup,
            additional_tests=additional_tests,
        )

        # Write file if requested
        if write_file:
            category_dir = self.output_dir / category.lower().replace(" ", "_")
            category_dir.mkdir(parents=True, exist_ok=True)

            test_file = category_dir / f"test_{self._to_snake_case(node_name)}.py"
            test_file.write_text(test_code)
            logger.info(f"Generated test file: {test_file}")

        return test_code

    def _generate_port_assertions(self, node_class: Type) -> str:
        """Generate assertions for node ports."""
        lines = []

        # Try to instantiate node to get ports
        try:
            node = node_class()

            # Check for input ports
            if hasattr(node, "inputs"):
                for port in node.inputs:
                    lines.append(
                        self.PORT_ASSERTION_TEMPLATE.format(
                            port_name=port.name,
                            port_type="input",
                        )
                    )

            # Check for output ports
            if hasattr(node, "outputs"):
                for port in node.outputs:
                    lines.append(
                        self.PORT_ASSERTION_TEMPLATE.format(
                            port_name=port.name,
                            port_type="output",
                        )
                    )

        except Exception as e:
            logger.warning(f"Could not analyze ports for {node_class.__name__}: {e}")
            lines.append("        pass  # TODO: Add port assertions manually if needed")

        return "\n".join(lines) if lines else "        pass  # No ports defined"

    def _generate_input_setup(self, node_class: Type) -> str:
        """Generate input setup code."""
        lines = []

        try:
            node = node_class()

            if hasattr(node, "inputs"):
                for port in node.inputs:
                    # Determine default value based on data type
                    default = self._get_default_value(
                        getattr(port, "data_type", None),
                        port.name,
                    )
                    lines.append(
                        self.INPUT_SETUP_TEMPLATE.format(
                            input_name=port.name,
                            default_value=default,
                        )
                    )

        except Exception as e:
            logger.warning(f"Could not analyze inputs for {node_class.__name__}: {e}")
            lines.append("        # TODO: Set up inputs manually - Auto-detection failed")

        return "\n".join(lines) if lines else "        pass  # No inputs to set"

    def _get_default_value(
        self,
        data_type: Optional[Any],
        port_name: str,
    ) -> str:
        """Get default value representation for a data type."""
        # Try to determine type from port name
        name_lower = port_name.lower()

        if "url" in name_lower:
            return '"https://example.com"'
        elif "selector" in name_lower:
            return '"#test-element"'
        elif "text" in name_lower or "content" in name_lower:
            return '"test text"'
        elif "path" in name_lower or "file" in name_lower:
            return '"/tmp/test_file.txt"'
        elif "timeout" in name_lower or "delay" in name_lower or "duration" in name_lower:
            return "1000"
        elif "count" in name_lower or "limit" in name_lower or "max" in name_lower:
            return "10"
        elif "enabled" in name_lower or "is_" in name_lower or "has_" in name_lower:
            return "True"
        elif "list" in name_lower or "items" in name_lower:
            return "[]"
        elif "dict" in name_lower or "data" in name_lower or "config" in name_lower:
            return "{}"

        # Default based on data type enum if available
        if data_type is not None:
            type_name = str(data_type).lower()
            if "string" in type_name:
                return '"test_value"'
            elif "int" in type_name or "number" in type_name:
                return "42"
            elif "float" in type_name:
                return "3.14"
            elif "bool" in type_name:
                return "True"
            elif "list" in type_name or "array" in type_name:
                return "[]"
            elif "dict" in type_name or "object" in type_name:
                return "{}"

        return '"test_value"'

    def _generate_additional_tests(self, node_class: Type) -> str:
        """Generate additional test cases based on node type."""
        tests = []
        node_name = node_class.__name__

        # Browser nodes
        if "Browser" in node_name or "Click" in node_name or "Navigate" in node_name:
            tests.append(self._browser_test_template(node_name))

        # HTTP nodes
        if "Http" in node_name or "Request" in node_name or "Api" in node_name:
            tests.append(self._http_test_template(node_name))

        # File nodes
        if "File" in node_name or "Read" in node_name or "Write" in node_name:
            tests.append(self._file_test_template(node_name))

        # Loop nodes
        if "Loop" in node_name or "ForEach" in node_name:
            tests.append(self._loop_test_template(node_name))

        return "\n".join(tests)

    def _browser_test_template(self, node_name: str) -> str:
        """Generate browser-specific tests."""
        return '''
    @pytest.mark.asyncio
    async def test_execute_with_mock_browser(self, node, context):
        """Test execution with mock browser."""
        from casare_rpa.testing import MockBrowserPool

        mock_pool = MockBrowserPool()
        context.register_service("browser_pool", mock_pool)

        # TODO: Configure mock page behavior
        # result = await node.execute(context)
        # assert mock_pool.was_called("acquire")
'''

    def _http_test_template(self, node_name: str) -> str:
        """Generate HTTP-specific tests."""
        return '''
    @pytest.mark.asyncio
    async def test_execute_with_mock_http(self, node, context):
        """Test execution with mock HTTP client."""
        from casare_rpa.testing import MockHttpClient

        mock_http = MockHttpClient().configure_response(
            "https://example.com/api",
            json={"status": "ok", "data": []}
        )
        context.register_service("http_client", mock_http)

        # TODO: Set up inputs and verify response handling
        # result = await node.execute(context)
        # assert mock_http.was_called("request")
'''

    def _file_test_template(self, node_name: str) -> str:
        """Generate file-specific tests."""
        return '''
    @pytest.mark.asyncio
    async def test_execute_with_temp_file(self, node, context, tmp_path):
        """Test execution with temporary file."""
        test_file = tmp_path / "test_file.txt"
        test_file.write_text("test content")

        context.set_variable("file_path", str(test_file))

        # TODO: Execute and verify file operations
        # result = await node.execute(context)
        # assert result.success
'''

    def _loop_test_template(self, node_name: str) -> str:
        """Generate loop-specific tests."""
        return '''
    @pytest.mark.asyncio
    async def test_execute_with_empty_list(self, node, context):
        """Test loop execution with empty list."""
        context.set_variable("items", [])

        # result = await node.execute(context)
        # Should handle empty list gracefully

    @pytest.mark.asyncio
    async def test_execute_with_items(self, node, context):
        """Test loop execution with items."""
        context.set_variable("items", ["a", "b", "c"])

        # result = await node.execute(context)
        # Should iterate over all items
'''

    def _to_snake_case(self, name: str) -> str:
        """Convert CamelCase to snake_case."""
        import re

        s1 = re.sub("(.)([A-Z][a-z]+)", r"\1_\2", name)
        return re.sub("([a-z0-9])([A-Z])", r"\1_\2", s1).lower()

    def generate_all(
        self,
        node_registry: Optional[Dict[str, str]] = None,
    ) -> Dict[str, str]:
        """
        Generate tests for all registered nodes.

        Args:
            node_registry: Optional registry dict (uses default if not provided)

        Returns:
            Dictionary of filename -> generated code
        """
        generated = {}

        try:
            if node_registry is None:
                from casare_rpa.nodes.registry_data import NODE_REGISTRY

                node_registry = NODE_REGISTRY

            for node_name, module_info in node_registry.items():
                try:
                    # Import node class
                    if isinstance(module_info, tuple):
                        module_name = module_info[0]
                    else:
                        module_name = module_info

                    full_module = f"casare_rpa.nodes.{module_name}"

                    import importlib

                    module = importlib.import_module(full_module)
                    node_class = getattr(module, node_name, None)

                    if node_class is not None:
                        test_code = self.generate_for_node(node_class)
                        test_filename = f"test_{self._to_snake_case(node_name)}.py"
                        generated[test_filename] = test_code

                except Exception as e:
                    logger.warning(f"Could not generate tests for {node_name}: {e}")

        except ImportError as e:
            logger.error(f"Could not import node registry: {e}")

        logger.info(f"Generated {len(generated)} test files")
        return generated


__all__ = ["NodeTestGenerator"]
