"""
Event system for monitoring dashboard real-time updates.

Connects orchestrator-level events (job status changes, robot heartbeats)
to WebSocket broadcasts for the React dashboard.
"""

import asyncio
from typing import Callable, Dict, List, Set
from enum import Enum, auto
from loguru import logger


class MonitoringEventType(Enum):
    """Event types for monitoring dashboard."""

    JOB_STATUS_CHANGED = auto()  # Job transitioned to new status
    ROBOT_HEARTBEAT = auto()  # Robot sent heartbeat
    QUEUE_DEPTH_CHANGED = auto()  # Queue depth updated


class MonitoringEventBus:
    """
    Simple event bus for monitoring dashboard events.

    Allows decoupling between the orchestrator (which tracks jobs/robots)
    and the WebSocket broadcast system (which pushes updates to browsers).

    Usage:
        # In orchestrator code
        event_bus.publish(
            MonitoringEventType.JOB_STATUS_CHANGED,
            {"job_id": "123", "status": "completed"}
        )

        # In WebSocket router startup
        event_bus.subscribe(
            MonitoringEventType.JOB_STATUS_CHANGED,
            on_job_status_changed
        )
    """

    _instance = None

    def __new__(cls):
        """Singleton pattern."""
        if cls._instance is None:
            cls._instance = super().__new__(cls)
            cls._instance._initialized = False
        return cls._instance

    def __init__(self):
        """Initialize event bus."""
        if self._initialized:
            return

        self._handlers: Dict[MonitoringEventType, List[Callable]] = {}
        self._initialized = True
        logger.info("MonitoringEventBus initialized")

    @classmethod
    def get_instance(cls) -> "MonitoringEventBus":
        """Get singleton instance."""
        return cls()

    def subscribe(self, event_type: MonitoringEventType, handler: Callable) -> None:
        """
        Subscribe to an event type.

        Args:
            event_type: Type of event to listen for
            handler: Async function to call when event occurs
                     Handler signature: async def handler(data: Dict) -> None
        """
        if event_type not in self._handlers:
            self._handlers[event_type] = []

        self._handlers[event_type].append(handler)
        logger.debug(f"Handler subscribed to {event_type.name}")

    def unsubscribe(self, event_type: MonitoringEventType, handler: Callable) -> None:
        """
        Unsubscribe from an event type.

        Args:
            event_type: Event type
            handler: Handler to remove
        """
        if event_type in self._handlers:
            try:
                self._handlers[event_type].remove(handler)
                logger.debug(f"Handler unsubscribed from {event_type.name}")
            except ValueError:
                logger.warning(f"Handler not found for {event_type.name}")

    async def publish(self, event_type: MonitoringEventType, data: Dict) -> None:
        """
        Publish an event to all subscribed handlers.

        Args:
            event_type: Type of event
            data: Event payload (will be passed to handlers)
        """
        if event_type not in self._handlers:
            logger.debug(f"No handlers for {event_type.name}")
            return

        handlers = self._handlers[event_type]
        logger.debug(f"Publishing {event_type.name} to {len(handlers)} handlers")

        # Call all handlers concurrently
        tasks = []
        for handler in handlers:
            try:
                # Handle both sync and async handlers
                if asyncio.iscoroutinefunction(handler):
                    tasks.append(handler(data))
                else:
                    # Wrap sync handler in async
                    async def wrapped():
                        handler(data)

                    tasks.append(wrapped())
            except Exception as e:
                logger.error(f"Error preparing handler for {event_type.name}: {e}")

        if tasks:
            # Run all handlers concurrently, don't fail if one fails
            results = await asyncio.gather(*tasks, return_exceptions=True)

            # Log any errors
            for i, result in enumerate(results):
                if isinstance(result, Exception):
                    logger.error(
                        f"Handler {i} for {event_type.name} failed: {result}"
                    )

    def clear_all(self) -> None:
        """Clear all subscriptions (for testing)."""
        self._handlers.clear()
        logger.debug("All event handlers cleared")


# Singleton instance
monitoring_event_bus = MonitoringEventBus.get_instance()
