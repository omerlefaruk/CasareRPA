import asyncio
import os
import json
import uuid
import httpx
from datetime import datetime
from dotenv import load_dotenv

# Load environment
load_dotenv()

ORCHESTRATOR_URL = os.getenv("ORCHESTRATOR_URL", "http://localhost:8000")
API_SECRET = os.getenv("API_SECRET", "").strip()
ROBOT_KEY = os.getenv("ORCHESTRATOR_API_KEY", "").strip()

# Minimal Workflow JSON: Start -> Log -> End
WORKFLOW_PAYLOAD = {
    "name": f"E2E Test {datetime.now().strftime('%H:%M:%S')}",
    "description": "Generated by E2E Test Runner",
    "graph": {
        "nodes": [
            {
                "id": "node_start",
                "type": "casare_rpa.nodes.logic.start.StartNode",
                "pos": [0, 0],
                "properties": {},
                "custom": {},
            },
            {
                "id": "node_log",
                "type": "casare_rpa.nodes.basic.log.LogNode",
                "pos": [200, 0],
                "properties": {
                    "message": "üëã Hello from E2E Test! System is Operational.",
                    "level": "INFO",
                },
                "custom": {},
            },
        ],
<<<<<<< HEAD
        "connections": [
            {"out": ["node_start", "exec_out"], "in": ["node_log", "exec_in"]}
        ],
=======
        "connections": [{"out": ["node_start", "exec_out"], "in": ["node_log", "exec_in"]}],
>>>>>>> d1c1cdb090b151b968ad2afaa52ad16e824faf0e
    },
}


async def run_e2e_test():
    print(f"üöÄ Starting E2E Test against {ORCHESTRATOR_URL}")
    print(f"üîë Using API Secret: {API_SECRET[:5]}...")

    async with httpx.AsyncClient(timeout=10.0) as client:
        # 1. Health Check
        print("\n1Ô∏è‚É£  Checking Orchestrator Health...")
        try:
            resp = await client.get(f"{ORCHESTRATOR_URL}/health")
            if resp.status_code == 200:
                print("   ‚úÖ Orchestrator is ONLINE")
            else:
                print(f"   ‚ùå Orchestrator Unhealthy: {resp.status_code}")
                return
        except Exception as e:
            print(f"   ‚ùå Failed to connect: {e}")
            print("   ‚ö†Ô∏è  Please ensure 'launch.bat' is running!")
            return

        # 2. Check Robot Status
        print("\n2Ô∏è‚É£  Checking Robot Fleet...")
        try:
            # Use X-Api-Key for Admin access
            headers = {"X-Api-Key": API_SECRET}
<<<<<<< HEAD
            resp = await client.get(
                f"{ORCHESTRATOR_URL}/api/v1/metrics/robots", headers=headers
            )
=======
            resp = await client.get(f"{ORCHESTRATOR_URL}/api/v1/metrics/robots", headers=headers)
>>>>>>> d1c1cdb090b151b968ad2afaa52ad16e824faf0e

            if resp.status_code == 200:
                payload = resp.json()

                if isinstance(payload, list):
                    robots = payload
                elif "data" in payload:
                    robots = payload["data"]
                else:
                    print(f"   ‚ùå Unexpected response format: {payload}")
                    return
                # Ensure it's a list
                if not isinstance(robots, list):
                    print(f"   ‚ùå 'data' is not a list: {type(robots)} - {robots}")
                    return

                online_robots = [r for r in robots if r["status"] == "online"]
                print(f"   ‚ÑπÔ∏è  Found {len(robots)} robots, {len(online_robots)} ONLINE")
                if not online_robots:
                    print("   ‚ö†Ô∏è  No robots online. Job will stay pending.")
                else:
                    print(f"   ‚úÖ Targeted Robot: {online_robots[0]['name']}")
            elif resp.status_code == 401:
                print("   ‚ùå Authentication Failed (401). Check API_SECRET.")
                return
            else:
                print(f"   ‚ùå API Error: {resp.status_code} {resp.text}")
                return
        except Exception as e:
            print(f"   ‚ùå Error checking robots: {e}")
            return

        # 3. Submit Job
        print("\n3Ô∏è‚É£  Submitting Workflow Job...")
        try:
            # We submit to /api/v1/jobs directly with ad-hoc workflow
            # Note: The actual endpoint might expect a saved workflow ID.
            # Let's try creating a workflow first.

            # A) Create Workflow
            # Check if /api/v1/workflows exists?
            # Assuming simplified submission via 'jobs' payload if supported,
            # otherwise allow creating regular workflow.

            # Let's try direct job submission with inline workflow (if supported)
            # OR create workflow then run it.

            create_resp = await client.post(
                f"{ORCHESTRATOR_URL}/api/v1/workflows",
                json=WORKFLOW_PAYLOAD,
                headers=headers,
            )

            if create_resp.status_code in (200, 201):
                wf_data = create_resp.json()["data"]
                wf_id = wf_data["id"]
                print(f"   ‚úÖ Workflow Created: {wf_id}")
            else:
                print(
                    f"   ‚ùå Failed to create workflow: {create_resp.status_code} {create_resp.text}"
                )
                return

            # B) Trigger Job
            job_payload = {
                "workflow_id": wf_id,
                "robot_id": None,  # Auto-assign
                "variables": {},
                "priority": 1,
            }

            job_resp = await client.post(
                f"{ORCHESTRATOR_URL}/api/v1/jobs", json=job_payload, headers=headers
            )

            if job_resp.status_code in (200, 201):
                job_data = job_resp.json()["data"]
                job_id = job_data["id"]
                print(f"   ‚úÖ Job Submitted: {job_id}")
            else:
<<<<<<< HEAD
                print(
                    f"   ‚ùå Failed to submit job: {job_resp.status_code} {job_resp.text}"
                )
=======
                print(f"   ‚ùå Failed to submit job: {job_resp.status_code} {job_resp.text}")
>>>>>>> d1c1cdb090b151b968ad2afaa52ad16e824faf0e
                return

        except Exception as e:
            print(f"   ‚ùå Submission Error: {e}")
            return

        # 4. Monitor Execution
        print(f"\n4Ô∏è‚É£  Monitoring Job {job_id}...")
        start_time = datetime.now()
        while (datetime.now() - start_time).seconds < 60:
            try:
<<<<<<< HEAD
                resp = await client.get(
                    f"{ORCHESTRATOR_URL}/api/v1/jobs/{job_id}", headers=headers
                )
=======
                resp = await client.get(f"{ORCHESTRATOR_URL}/api/v1/jobs/{job_id}", headers=headers)
>>>>>>> d1c1cdb090b151b968ad2afaa52ad16e824faf0e
                state = resp.json()["data"]["status"]
                print(f"   ‚è≥ Status: {state}")

                if state == "completed":
                    print("\nüéâ SUCCESS! Workflow completed successfully.")

                    # 5. Check Output/Logs?
                    # (Implementation dependent, usually getting logs endpoint)
                    return
                elif state == "failed":
                    data = resp.json()["data"]
<<<<<<< HEAD
                    print(
                        f"\n‚ùå FAILURE! Job failed: {data.get('error_message', 'Unknown error')}"
                    )
=======
                    print(f"\n‚ùå FAILURE! Job failed: {data.get('error_message', 'Unknown error')}")
>>>>>>> d1c1cdb090b151b968ad2afaa52ad16e824faf0e
                    return

                await asyncio.sleep(2)
            except Exception as e:
                print(f"   ‚ö†Ô∏è Polling error: {e}")
                await asyncio.sleep(2)

        print("\n‚è±Ô∏è  Timeout waiting for job completion.")


if __name__ == "__main__":
    asyncio.run(run_e2e_test())
